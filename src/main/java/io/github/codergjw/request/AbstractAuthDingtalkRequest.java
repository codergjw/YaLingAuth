package io.github.codergjw.request;import io.github.codergjw.cache.AuthStateCache;import io.github.codergjw.config.AuthConfig;import io.github.codergjw.config.AuthSource;import io.github.codergjw.entity.AuthCallback;import io.github.codergjw.entity.AuthToken;import io.github.codergjw.entity.AuthUser;import io.github.codergjw.enums.AuthUserGender;import io.github.codergjw.exception.AuthException;import io.github.codergjw.utils.GlobalAuthUtils;import io.github.codergjw.utils.HttpUtils;import io.github.codergjw.utils.UrlBuilder;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;/** * @ClassName: AbstractAuthDingtalkRequest * @Author: 小飞 * @Date: 2023/5/13 15:06 * @Description: 钉钉登录抽象类，负责处理使用钉钉账号登录第三方网站和扫码登录第三方网站两种钉钉的登录方式 */public abstract class AbstractAuthDingtalkRequest extends AuthDefaultRequest {    public AbstractAuthDingtalkRequest(AuthConfig config, AuthSource source) {        super(config, source);    }    public AbstractAuthDingtalkRequest(AuthConfig config, AuthSource source, AuthStateCache authStateCache) {        super(config, source, authStateCache);    }    /**     * 获取accessToken     *     * @param authCallback 授权成功后的回调参数     * @return     */    @Override    protected AuthToken getAccessToken(AuthCallback authCallback) {        return AuthToken.builder().accessCode(authCallback.getCode()).build();    }    @Override    protected AuthUser getUserInfo(AuthToken authToken) {        String code = authToken.getAccessCode();        JSONObject param = new JSONObject();        param.put("tmp_auth_code", code);        String response = new HttpUtils(config.getHttpConfig()).post(userInfoUrl(authToken), param.toJSONString()).getBody();        JSONObject object = JSON.parseObject(response);        if (object.getIntValue("errcode") != 0) {            throw new AuthException(object.getString("errmsg"));        }        object = object.getJSONObject("user_info");        AuthToken token = AuthToken.builder()                .openId(object.getString("openid"))                .unionId(object.getString("unionid"))                .build();        return AuthUser.builder()                .rawUserInfo(object)                .uuid(object.getString("unionid"))                .nickname(object.getString("nick"))                .username(object.getString("nick"))                .gender(AuthUserGender.UNKNOWN)                .source(source.toString())                .token(token)                .build();    }    /**     * 返回带{@code state}参数的授权url，授权回调时会带上这个{@code state}     *     * @param state state 验证授权流程的参数，可以防止csrf     * @return 返回授权地址     * @since 1.9.3     */    @Override    public String authorize(String state) {        return UrlBuilder.fromBaseUrl(source.authorize())                .queryParam("response_type", "code")                .queryParam("appid", config.getClientId())                .queryParam("scope", "snsapi_login")                .queryParam("redirect_uri", config.getRedirectUri())                .queryParam("state", getRealState(state))                .build();    }    /**     * 返回获取userInfo的url     *     * @param authToken 用户授权后的token     * @return 返回获取userInfo的url     */    @Override    protected String userInfoUrl(AuthToken authToken) {        // 根据timestamp, appSecret计算签名值        String timestamp = System.currentTimeMillis() + "";        String urlEncodeSignature = GlobalAuthUtils.generateDingTalkSignature(config.getClientSecret(), timestamp);        return UrlBuilder.fromBaseUrl(source.userInfo())                .queryParam("signature", urlEncodeSignature)                .queryParam("timestamp", timestamp)                .queryParam("accessKey", config.getClientId())                .build();    }}