package cn.wen.oauth.utils;import cn.wen.oauth.cache.AuthStateCache;import cn.wen.oauth.config.AuthConfig;import cn.wen.oauth.config.AuthSource;import cn.wen.oauth.entity.AuthCallback;import cn.wen.oauth.enums.AuthResponseStatus;import cn.wen.oauth.exception.AuthException;/** * @ClassName: AuthChecker * @Author: 小飞 * @Date: 2023/5/9 21:10 * @Description: 授权配置类的校验器 */public class AuthChecker {    /**     * 是否支持第三方登录     *     * @param config     * @param source     * @return     */    public static boolean isSupportedAuth(AuthConfig config, AuthSource source) {        boolean isSupported = StringUtils.isNotEmpty(config.getClientId())                && StringUtils.isNotEmpty(config.getClientSecret());        return isSupported;    }    /**     * 检查配置合法性。针对部分平台， 对redirect uri有特定要求。     * 一般来说redirect uri都是http://，而对于facebook平台， redirect uri 必须是https的链接     *     * @param config     * @param source     */    public static void checkConfig(AuthConfig config, AuthSource source) {        String redirectUri = config.getRedirectUri();        if (config.isIgnoreCheckRedirectUri()) {            return;        }        if (StringUtils.isEmpty(redirectUri)) {            throw new AuthException(AuthResponseStatus.ILLEGAL_REDIRECT_URI, source);        }        if (!GlobalAuthUtils.isHttpProtocol(redirectUri) && !GlobalAuthUtils.isHttpsProtocol(redirectUri)) {            throw new AuthException(AuthResponseStatus.ILLEGAL_REDIRECT_URI, source);        }    }    /**     * 校验回调传回的Code     * 传入AuthSource 和 AuthCallback 对应不同平台使用不同的参数接受code来实现     * @param source     * @param callback     */    public static void checkCode(AuthSource source, AuthCallback callback) {        String code = callback.getCode();        if (StringUtils.isEmpty(code)) {            throw new AuthException(AuthResponseStatus.ILLEGAL_CODE, source);        }    }    /**     * 校验回调传回的State     * 1. {@code state}已使用，被正常清除     * 2. {@code state}为前端伪造，本身就不存在     * 传入AuthSource 和 AuthCallback 对应不同平台使用不同的参数接受code来实现     * @param source 当前授权的来源平台     * @param state 一定不为空     * @param stateCache State的缓存实现     */    public static void checkState(String state, AuthSource source, AuthStateCache stateCache) {        // 主要校验是否为空或者不包含当前state则抛出异常        if (StringUtils.isEmpty(state) || !stateCache.containsKey(state)) {            throw new AuthException(AuthResponseStatus.ILLEGAL_STATUS, source);        }    }}